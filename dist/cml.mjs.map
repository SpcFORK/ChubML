{"version":3,"sources":["../src/cml.ts"],"sourcesContent":["// @ CowSTD\nimport { chaosGl, NOOP, ANOOP } from './cst';\nimport { CowErr } from './CowErr';\n\nimport './global'\n\nvar checkEnvironment = () => {\n  let isImportSupported = false;\n  try {\n    eval('import.meta')\n    isImportSupported = true;\n  }\n  catch { }\n\n  if (isImportSupported) {\n    // ES Module environment\n    return 'ES Module';\n  }\n\n  else if (typeof module\n    !== 'undefined'\n    && module?.exports\n    && typeof window\n    === 'undefined') {\n    // Node.js environment\n    return 'Node';\n  }\n\n  else if (typeof window\n    !== 'undefined'\n    && typeof window?.document\n    !== 'undefined') {\n    // Browser environment\n    return 'Browser';\n  }\n\n  else {\n    // Unknown environment\n    return 'Unknown';\n  }\n}\n\n// @ CML\nimport { CML_Static } from './static';\n\ninterface CILElement {\n  c: string;\n  i: string | number;\n}\n\ninterface ChubNode {\n  tag: string,\n  id: string,\n  class: string,\n  content: string,\n  data: string,\n  style: string,\n  attr: string,\n  indent: number,\n}\n\ninterface SortedCILE extends CILElement {\n  children: SortedCILE[]\n  o?: ChubNode\n}\n\ntype CILEList = CILElement[];\ntype SortedCIL = SortedCILE[];\n\n/**\n * A ChubML instance.\n * \n * =-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-\n *\n * 2024\n * SpcFORK - ChubML\n * Copyright (c) SpcFORK\n * \n * =-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-\n *\n * ```go\n *       ,\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\",^,\"\"\"\"\"\"\"\"\"\"\"\",\n *     .l ?]]]]]]]]]]]]]]]].~.????????????.I\n *     \",!l]IIIIIIIIIIIIIIII,< ]]]]]]]]]]]] l\n *     l ]]]lllllllllllllIII:> ]]]]]]]]]]]] l\n *     l:iii>>>>>>>>>>>>>]]] ~ ]]]]]]]]]]]] l\n *     l`++++++++++++++++---.~ ]]]]]]]]]]]] l\n *     lIIIIIIIIIIIIIIIIIIII;~.??????----?? l\n *     lIlllllllllllllllllll:iI\"\"\"\"\"\",;:;''l;\".\n *     l;lllllllllllllllllll:l    '^,,Iii??]-i;\".\n *     `I,I:::::::::I,,,,,,,:`   ,;ii??]]]]]]]-i\",\n *      ,:iiiiiiiii:,          :IIii!!!!!!!?]]]I:\"\n *      l ]]]]]]]]] l           ^`````````l.]]]] i\n *      l ]]]]]]]]] l                   .`l.]]]]?.I\n *      l.?]]]]]]]] l         ,\"\"\"\"\"\"\"\"\";!!?]]]]] l\n *      `i ]]]]]]]] l        I.?????????-]]]]]]]I\";\n *       ;:I]]]]]]]l;\"\"\"\"\"\"\",! ]]]]]]]]]]]]]]]?!^;\n *        I,i-]]]]]]-???????.~ ]]]]]]]]]]]]]?!,,^\n *         ^IIi?-]]]]]]]]]]] ~ ]]]]]]]]]]??!,,^\n *           ^I\"I!!!!!!!!!!!\">:!!!!!!!!!!,\",^\n *              ^```````````^ ^``````````^\n * ```\n * \n * =-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-\n * \n * TODO:\n * - Make code cleaner/compact.\n * - Make ECSS.\n * - Create CHUBECSS Parser.\n * \n * =-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-\n * \n * TOUR:\n *   *Q-Sel:\n *   $()\n *   *Array matcher\n *       arrMatch\n *   *Parser:\n *     parse()\n *       -> sortInd()\n *       -> stringi()\n *\n * =-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=--=-=-=-=-\n*/\nexport class ChubMLMod extends CML_Static {\n  static ChubML = ChubMLMod\n  ChubML = ChubMLMod\n\n  // @ Options\n  static {\n    chaosGl.chubinjected = NOOP\n    chaosGl.chubstart = NOOP\n\n    chaosGl.lastChub ||= \"\"\n    chaosGl.cbMode ||= \"\"\n\n    window.onload = () =>\n      chaosGl.chubstart?.()\n  }\n\n  s = CML_Static\n\n  styled = {} as Record<string, any>\n\n  #Rexps = () => this.s.Rexps\n  #initialFormat(str: string) {\n    let r = this.#Rexps\n    return str\n      .replace(r().lineWithComment, \"\")\n      .replace(r().formatspace2, \"\\n\")\n      .replace(r().formatspace1, \"\\n\")\n  }\n\n  #cascadeIndentList(str: string) {\n    let strLines = str.split(/;/);\n\n    let col = [] as CILEList\n\n    for (const line of strLines) col.push({\n      c: line.trim(),\n      i: line.search(/\\S/)\n    });\n\n    return col;\n  }\n\n  #sortCILIndent(contents: CILEList) {\n    const sortedContents = [];\n    let parentStack = [];\n\n    for (const content of contents) {\n      const currentIndent = content.i;\n      const currentContent = { c: content.c, i: currentIndent, children: [] };\n\n      while (parentStack.length > 0 && currentIndent <= parentStack[parentStack.length - 1].i)\n        parentStack.pop();\n\n      if (parentStack.length > 0) {\n        const parent = parentStack[parentStack.length - 1];\n        parent.children.push(currentContent);\n      } else {\n        sortedContents.push(currentContent);\n      }\n\n      parentStack.push(Object.assign(currentContent));\n    };\n\n    return sortedContents\n  }\n\n  #makeDef = (): ChubNode => ({\n    tag: \"\",\n    id: \"\",\n    class: \"\",\n    content: \"\",\n    data: \"\",\n    style: \"\",\n    attr: \"\",\n    indent: 0,\n  })\n\n  #makeIndexes = () => ({\n    str: 0,\n    tmp: 0,\n  })\n\n  #specialTags = [\n    'area',\n    'base',\n    'br',\n    'col',\n    'embed',\n    'hr',\n    'img',\n    'input',\n    'link',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wbr'\n  ]\n\n  #handleScript(scrmatch: string[] | null) {\n    const r = this.#Rexps;\n\n    let issrc = scrmatch![1].includes(\"src=\");\n    let execafter = scrmatch![1].includes(\"\\\"execafter\\\";\\n\");\n\n    var dostill = true;\n\n    const fetchScript = async (src: string) => fetch(src)\n      .then((js) => {\n        return js.text();\n      })\n      .then((text) => {\n        // Append a script tag to the body\n        try {\n          let script = document.createElement(\"script\");\n          script.type = \"text/javascript\";\n          script.text = text;\n          document.body.appendChild(script);\n        }\n        catch (error) { console.log(error, this.s.errorList.scripterror); }\n      });\n\n    // Source Check\n    if (issrc && scrmatch) {\n      let srcis = scrmatch![1].match(/src=\"(.*)\"/);\n      if (srcis) {\n        fetchScript(srcis[1]);\n\n        dostill = false;\n      }\n    }\n\n    // Eval content (not SRC).\n    if (scrmatch !== null && dostill) {\n      try { eval(scrmatch[1]) }\n      catch (error) { console.error(error, this.s.errorList.scripterror) }\n    }\n  }\n\n  #traverse(cil: SortedCILE, i: number, indexes: { str: any; tmp: number; }, v = ''): [SortedCILE, { str: number, tmp: number }] {\n    const r = this.#Rexps\n\n    let indentString = \"  \"\n\n    let str = cil.c\n    let isStr = str.search(r().betweenQuote)\n    let hasOpts = str.search(r().betweenCol)\n    let isscr = str.match(r().script)\n\n    let def = this.#makeDef()\n    let tempC = this.#makeDef()\n\n    // Script Operation\n    if (isscr !== null) {\n      this.#handleScript(r().script.exec(str));\n    }\n\n    if (isStr !== -1) {\n      let tempLines = str.split(r().betweenCol)\n      let content = str.split(r().betweenQuote)[1]\n\n      if (hasOpts == null) {\n        tempC = def\n      } else {\n        var inner = tempLines[1] || \"\"\n        this.#checkAttr(tempC, inner.split(\" \"))\n      }\n\n      indexes.str++\n      tempC.content = content\n    } else {\n      this.#checkAttr(tempC, str.split(\" \"))\n    }\n\n    var indc = indentString.repeat(i)\n\n    cil.o = tempC\n    cil.i = indc\n\n    if (cil.children) {\n      cil.children.forEach(child => this.#traverse(child, i + 1, indexes, v));\n    }\n\n    return [cil, indexes]\n  }\n\n  #checkAttr = (tempC: ChubNode, arr: any[]) => arr.forEach((param, pind) => {\n    // ATTR's\n    switch (param[0]) {\n      case \"#\":\n        this.#handleID(tempC, param);\n        break;\n\n      case \".\":\n        this.#handleClass(tempC, param);\n        break;\n\n      case \"$\":\n        let dataParam = this.attrSyn(param);\n        if (!dataParam) return;\n\n        let dataB = `data-${dataParam[0].slice(1) + \"=\\\"\" + dataParam[1] + \"\\\"\"}`;\n        tempC.data = `${tempC.data ? tempC.data + \" \" : \"\"}${dataB}`;\n        break;\n\n      case \"%\":\n        let attrParam = this.attrSyn(param);\n        if (!attrParam) return;\n\n        let attrB = `${attrParam[0].slice(1) + \"=\\\"\" + attrParam[1] + \"\\\"\"}`;\n        // console.log(attrB)\n        tempC.attr = `${tempC.attr ? tempC.attr + \" \" : \"\"}${attrB}`;\n\n        break;\n\n      case \"@\":\n        /*\n          We need to:\n \n          Extract the @val from the param.\n          If as params, get params.\n \n          E.G.\n          @fetchw=https://www.google.com\n        */\n        param = this.#handleAtCode(param, tempC);\n        break;\n\n      default:\n        tempC.tag = `${tempC.tag ? tempC.tag + \" \" : \"\"}${param}`;\n    }\n  })\n\n  #handleClass(tempC: ChubNode, param: any) {\n    tempC.class = `${tempC.class ? tempC.class + \" \" : \"\"}${param.replace(\".\", \" \")}`;\n  }\n\n  #handleID(tempC: ChubNode, param: any) {\n    tempC.id = `${tempC.id ? tempC.id + \" \" : \"\"}${param.replace(\"#\", \" \")}`;\n  }\n\n  #handleAtCode(param: any, tempC: ChubNode) {\n    console.log(\"using @\", `${param}`.slice(8), `${param}`.split(/[|:>=\\-\\)!~]/gm)[1].slice(1));\n\n    if (param.includes(\"fetchw\")) (async () => {\n      param = param.slice(8);\n\n      if (window?.location?.origin) {\n        param = `${param}`.includes(\"{{ORIG}}\")\n          ? param.replace(\"{{ORIG}}\", window.location.origin)\n          : param;\n      }\n\n      tempC.tag = tempC.tag\n        ? tempC.tag\n        : 'fetcherBlock';\n\n      tempC.data = (\n        `${tempC.data ? tempC.data + \" \" : \"\"}data-fetchw=\"${param}\"`\n        + ` data-instance=\"${new Date().getTime()}\"`\n      );\n\n      let fw = await fetch(await this.findFile([param])) || {\n        text: () => { return param; },\n      };\n\n      let fwtext = await fw.text();\n      tempC.content = `${fwtext ? fwtext : \"\"}`;\n\n      // If window is loaded before script end, replace content.\n      if (window?.location?.origin) {\n        let el = this.$(`[${tempC.data.split(' ').join('][')}]`)\n        if (el)\n          el.innerHTML = tempC.content.replace(/\\n/g, '\\n</br>\\n');\n      }\n    })();\n    return param;\n  }\n\n  #parseChubNode(cil: SortedCILE, opts = this.#makeIndexes()) {\n    const o = cil.o!\n    if (!o) throw new CowErr(`No CIL object found!`)\n\n    let isTemplate = false\n    let shorter = false\n\n    let specialfind = this.arrMatch(o.tag, this.#specialTags)\n    let isSpecial = specialfind.count\n    let inList = specialfind.list\n\n    let html = ''\n\n    this.#parseTemplates(cil, opts);\n\n    html = `\\n${cil.i}<${o.tag}`;\n\n    const is = (v: any) => !!v\n    const addTo = (v: any) => html += v\n\n    switch (true) {\n      // case !!o().class: html += ` class=\"${o().class.slice(1)}\"`\n      case is(o.class): addTo(` class=\"${o.class\n        }\"`)\n      case is(o.id): addTo(` id=\"${o.id}\"`)\n      case is(o.style): addTo(` style=\"${o.style}\"`)\n      case is(o.data): addTo(` ${o.data}`)\n      case is(o.attr): addTo(` ${o.attr}`)\n    }\n\n    if (isSpecial > 0) shorter = true\n\n    html += shorter\n      ? \" />\\n\"\n      : \">\\n\";\n\n    // This is enough for certain tags.\n    for (const child of cil.children) switch (child.c[0]) {\n      case \"\\\"\":\n        html += child.i + child.c.slice(1, child.c.length - 1);\n        break;\n\n      default:\n        html += child.i + this.#parseChubNode(child, opts);\n    }\n\n    html += !shorter\n      ? `\\n${cil.i}</${o.tag}>\\n`\n      : \"\\n\"\n\n    // ¯\\_(ツ)_/¯ Quickest fix.\n    if (html.search(\"<>\")) html = html\n      .replace(\"<>\", \"\")\n      .replace(\"</>\", \"\")\n\n    if (html.includes(\"head\")) {\n\n      for (let stydm in this.styled) {\n        if (this.styled[stydm] === true && this.styled.styles[stydm]) {\n          html = html.replace(\"<head>\", \"<head>\\n\" + this.styled.styles[stydm])\n\n          // Set to \"has\" since we check earlier if the value is false to define it\n          // Also, might use later, need to exist, not be true.\n          this.styled[stydm] = \"has\"\n        }\n      }\n\n    }\n\n    return html\n  }\n\n  #parseTemplates(cil: SortedCILE, opts = this.#makeIndexes()) {\n    const { o } = cil\n    if (!o) throw new CowErr(`No CIL object found!`)\n    switch (o.tag) {\n\n    }\n  }\n\n  #constuctFrom(cil: SortedCILE, v = '') {\n    let indexes = this.#makeIndexes()\n\n    let travRes = this.#traverse(cil, 0, indexes, v);\n\n    // @Crossover\n    { [cil, indexes] = travRes }\n\n    let res = this.#parseChubNode(cil, indexes)\n\n    return res\n  }\n\n  parse(source: string) {\n    let str = this.#initialFormat(source)\n\n    let indList = this.#cascadeIndentList(str)\n\n    let sorted = this.#sortCILIndent(indList);\n\n    return this.#constuctFrom(sorted[0]);\n  }\n\n  async findFile(fileLocations: any) {\n    for (const location of fileLocations) {\n      try {\n        const response = await fetch(location);\n\n        // Check if the response was successful (status code in the range of 200-299)\n        if (response.ok) {\n          return location; // Return the valid file location\n        }\n      } catch (error) {\n        // Handle any errors that occur during the fetch request\n        console.error(`Error fetching file from '${location}':`, error);\n      }\n    }\n\n    // Return null if no valid file location was found\n    return null;\n  }\n\n  ChubRep(doc: string, quirky = \"<!DOCTYPE html>\") {\n    (doc as any) = this.parse(doc);\n    document.open();\n    document.write(quirky + '\\n' + doc);\n    document.close();\n  }\n\n  injectChub(input: string) {\n    // var input = `\n    // div;\n    //   \"wow, im super simple. <br>\n    //   and supper COOOL!\";\n    //   hr #wow $hey=lol .very .omg .neat %omg=js|is|cool;\n    //   :Super .cool: \"WOOO!\";\n    //     span .woah;\n    //       \"wow!\";\n    // `;\n\n    var htmlCode = this.parse(input);\n\n    if (chaosGl.chubDev == true) console.log(htmlCode)\n\n    let locationB = chaosGl.chubLocation || \"chub\"\n    let locationGot = this.$(locationB)\n    if (!locationGot) locationB = \"body\"\n    else locationGot.innerHTML = htmlCode;\n\n    // On finish, run finish.\n    chaosGl.chubinjected?.(locationGot);\n  }\n\n  Router = class Router {\n    __env__ = checkEnvironment();\n\n    constructor() {\n      switch (this.__env__) {\n        case \"Node\":\n          break;\n        case \"Browser\":\n          break;\n      }\n    }\n\n  }\n\n  // Reformat Attributes to prevent conflicts and such.\n  CHUBfax(tex: string, sep = \" \") {\n    let modtxt = tex || \"\";\n    modtxt = modtxt\n      .replace(\"=\", \"|e\")\n      .replace(\";\", \"|col\")\n      .replace(\"\\\"\", \"|qw\")\n      .replace(sep, \"|\")\n\n    return modtxt\n  }\n\n  attrSyn(tex: string) {\n    try {\n      if (`${tex}`.match(/=/gm)!?.length > 1) throw this.s.errorList.eqspl3\n\n      let attrParam = tex\n        // Tokenize\n        .replace(\"=\", \" spcfork.Equals.Token \")\n        .replace(\"\\\\|\", \" spcfork.Pipe.Token \")\n\n        .replace(/\\|e/gm, \"=\")\n        .replace(/\\|col/gm, \";\")\n        .replace(/\\|qw/gm, \"\\\"\")\n        .replace(/\\|/gm, \" \")\n\n        .replace(\" spcfork.Pipe.Token \", \"|\")\n\n        // Split at Token to prevent multiple splits.\n        .split(\" spcfork.Equals.Token \")\n\n      // console.log(attrParam.length, attrParam)\n      return attrParam\n    } catch { }\n  }\n\n  /**\n   * Fetch a web page and convert it to CHUB\n   * @param {string} url The URL of the web page to fetch\n   * @returns The CHUB representation of the web page\n   */\n  async CHUBWFetch(url: string | URL | Request): Promise<string> {\n    const response = await fetch(url);\n    if (!response?.ok)\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    const html = await response.text();\n    console.log(this.htmlToChub(html));\n    return this.htmlToChub(html);\n  }\n\n  getURLbit() {\n    var url = window.location.href;\n    var parts = url.split('/');\n    var lastPart = parts[parts.length - 1];\n\n    return lastPart;\n  }\n\n  CHUBsanitize(input: string) {\n    var element = document.createElement('div');\n    element.innerText = input;\n    var sanitizedInput = element.innerHTML;\n    return sanitizedInput;\n  }\n\n  DupeCollection = {} as Record<string, any>\n  /**\n   * @param {string} dupe - The dupe to be added to the collection.\n   * @returns {object} - The edited dupe, the dupe collection, and the stringified and parsed collection.\n   */\n  CHUBduper(dupe: string = \"p;\"): object {\n    if (!this.DupeCollection) {\n      this.DupeCollection = {};\n    }\n\n    if (this.DupeCollection[dupe] !== undefined) {\n      this.DupeCollection[dupe] += 1;\n    } else {\n      this.DupeCollection[dupe] = 0;\n    }\n\n    let editedDupe;\n    if (dupe.includes(\";\")) {\n      let d = dupe.split(\";\");\n      d[0] += ` #${this.DupeCollection[dupe]}`;\n      editedDupe = d.join(\"\");\n    } else {\n      editedDupe = dupe + \";\";\n    }\n\n    return {\n      editedDupe,\n      D: this.DupeCollection,\n      s: (() => JSON.stringify(this.DupeCollection)),\n      c: (() => JSON.parse(JSON.stringify(this.DupeCollection))),\n    };\n  }\n\n  CHUBstrprep(str: string) {\n    return str\n      .replace(/[.*+?^${}()|[\\]\\\\\"';:]/g, '\\\\$&')\n      .replace(/[;]/g, '|col')\n  }\n\n  CHUBunmess(str: string) {\n    const escapedStr = str.replace(/\\\\\\\"/g, '\"');\n    const unescapedStr = escapedStr.replace(/\\\\\\|col/g, ',');\n\n    return [\n      unescapedStr,\n      JSON.parse(unescapedStr),\n    ]\n  }\n\n  // ARARARAR\n  htmlToChub = (html: string, delim = \"\") => {\n    const doc = new DOMParser().parseFromString(html, 'text/html');\n\n    return this.#getChubML(doc.documentElement, '', delim)\n  }\n\n  #getChubML = (node: Element, indent = '', delim = '') => {\n    let chubML = '';\n\n    // Process node name\n    chubML += `${indent}${node.nodeName.toLowerCase()}`;\n\n    // Process attributes\n\n    if (node.attributes.length > 0) {\n      const attrs = Array.from(node.attributes);\n      chubML = this.#handleAttr(attrs, chubML);\n    }\n\n    // Process child nodes\n    if (node.childNodes.length > 0)\n      chubML = this.#handleChildren(chubML, node, indent, delim);\n    else\n      chubML += ';\\n';\n\n    return chubML;\n  }\n\n  #handleChildTextNode(child: Element, indent: string) {\n    if (!child.textContent) return '';\n    let t = child.textContent.trim();\n    if (t != \"\") return `${indent}  \"${t}\";\\n`;\n  }\n\n  #handleChildren(chubML: string, node: Element, indent: string, delim: string) {\n    chubML += ';\\n';\n    const childNodes = Array.from(node.childNodes);\n    for (const child of childNodes) switch (child.nodeType) {\n      case Node.TEXT_NODE:\n        chubML += this.#handleChildTextNode(child as Element, indent);\n        break;\n      case Node.ELEMENT_NODE:\n        chubML += this.#getChubML(child as Element, indent + '  ', delim);\n        break;\n    }\n    chubML += `${indent}${delim}\\n`;\n    return chubML;\n  }\n\n  #handleAttr(attrs: Attr[], chubML: string) {\n    const cfv = (attr: Attr) => this.CHUBfax(attr.value)\n    for (const attr of attrs) switch (attr.name.toLowerCase()) {\n      case 'class':\n        chubML += ` .${cfv(attr)}`;\n        break;\n      case 'id':\n        chubML += ` #${cfv(attr)}`;\n\n      default: chubML += ` %${attr.name}=${cfv(attr)}`;\n    }\n    return chubML;\n  }\n\n  constructor() {\n    super()\n\n    try { this.#elevateToWindow() } catch { }\n  }\n\n  #elevateToWindow() {\n    \n  }\n}\n\nconst chubml = new ChubMLMod;\n\n// @ Exporter\ntry { module.exports = chubml } catch { }\ntry { chaosGl.window.ChubML = chubml } catch { }"],"mappings":";;;;;;;;;;;;;AAMA,IAAI,mBAAmB,MAAM;AAC3B,MAAI,oBAAoB;AACxB,MAAI;AACF,SAAK,aAAa;AAClB,wBAAoB;AAAA,EACtB,QACM;AAAA,EAAE;AAER,MAAI,mBAAmB;AAErB,WAAO;AAAA,EACT,WAES,OAAO,WACV,eACD,QAAQ,WACR,OAAO,WACN,aAAa;AAEjB,WAAO;AAAA,EACT,WAES,OAAO,WACV,eACD,OAAO,QAAQ,aACd,aAAa;AAEjB,WAAO;AAAA,EACT,OAEK;AAEH,WAAO;AAAA,EACT;AACF;AAoFO,IAAM,YAAN,MAAM,mBAAkB,WAAW;AAAA,EACxC,OAAO,SAAS;AAAA,EAChB,SAAS;AAAA,EAGT,OAAO;AACL,YAAQ,eAAe;AACvB,YAAQ,YAAY;AAEpB,YAAQ,aAAa;AACrB,YAAQ,WAAW;AAEnB,WAAO,SAAS,MACd,QAAQ,YAAY;AAAA,EACxB;AAAA,EAEA,IAAI;AAAA,EAEJ,SAAS,CAAC;AAAA,EAEV,SAAS,MAAM,KAAK,EAAE;AAAA,EACtB,eAAe,KAAa;AAC1B,QAAIA,KAAI,KAAK;AACb,WAAO,IACJ,QAAQA,GAAE,EAAE,iBAAiB,EAAE,EAC/B,QAAQA,GAAE,EAAE,cAAc,IAAI,EAC9B,QAAQA,GAAE,EAAE,cAAc,IAAI;AAAA,EACnC;AAAA,EAEA,mBAAmB,KAAa;AAC9B,QAAI,WAAW,IAAI,MAAM,GAAG;AAE5B,QAAI,MAAM,CAAC;AAEX,eAAW,QAAQ,SAAU,KAAI,KAAK;AAAA,MACpC,GAAG,KAAK,KAAK;AAAA,MACb,GAAG,KAAK,OAAO,IAAI;AAAA,IACrB,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,eAAe,UAAoB;AACjC,UAAM,iBAAiB,CAAC;AACxB,QAAI,cAAc,CAAC;AAEnB,eAAW,WAAW,UAAU;AAC9B,YAAM,gBAAgB,QAAQ;AAC9B,YAAM,iBAAiB,EAAE,GAAG,QAAQ,GAAG,GAAG,eAAe,UAAU,CAAC,EAAE;AAEtE,aAAO,YAAY,SAAS,KAAK,iBAAiB,YAAY,YAAY,SAAS,CAAC,EAAE;AACpF,oBAAY,IAAI;AAElB,UAAI,YAAY,SAAS,GAAG;AAC1B,cAAM,SAAS,YAAY,YAAY,SAAS,CAAC;AACjD,eAAO,SAAS,KAAK,cAAc;AAAA,MACrC,OAAO;AACL,uBAAe,KAAK,cAAc;AAAA,MACpC;AAEA,kBAAY,KAAK,OAAO,OAAO,cAAc,CAAC;AAAA,IAChD;AAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,WAAW,OAAiB;AAAA,IAC1B,KAAK;AAAA,IACL,IAAI;AAAA,IACJ,OAAO;AAAA,IACP,SAAS;AAAA,IACT,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN,QAAQ;AAAA,EACV;AAAA,EAEA,eAAe,OAAO;AAAA,IACpB,KAAK;AAAA,IACL,KAAK;AAAA,EACP;AAAA,EAEA,eAAe;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EAEA,cAAc,UAA2B;AACvC,UAAM,IAAI,KAAK;AAEf,QAAI,QAAQ,SAAU,CAAC,EAAE,SAAS,MAAM;AACxC,QAAI,YAAY,SAAU,CAAC,EAAE,SAAS,gBAAkB;AAExD,QAAI,UAAU;AAEd,UAAM,cAAc,OAAO,QAAgB,MAAM,GAAG,EACjD,KAAK,CAAC,OAAO;AACZ,aAAO,GAAG,KAAK;AAAA,IACjB,CAAC,EACA,KAAK,CAAC,SAAS;AAEd,UAAI;AACF,YAAI,SAAS,SAAS,cAAc,QAAQ;AAC5C,eAAO,OAAO;AACd,eAAO,OAAO;AACd,iBAAS,KAAK,YAAY,MAAM;AAAA,MAClC,SACO,OAAO;AAAE,gBAAQ,IAAI,OAAO,KAAK,EAAE,UAAU,WAAW;AAAA,MAAG;AAAA,IACpE,CAAC;AAGH,QAAI,SAAS,UAAU;AACrB,UAAI,QAAQ,SAAU,CAAC,EAAE,MAAM,YAAY;AAC3C,UAAI,OAAO;AACT,oBAAY,MAAM,CAAC,CAAC;AAEpB,kBAAU;AAAA,MACZ;AAAA,IACF;AAGA,QAAI,aAAa,QAAQ,SAAS;AAChC,UAAI;AAAE,aAAK,SAAS,CAAC,CAAC;AAAA,MAAE,SACjB,OAAO;AAAE,gBAAQ,MAAM,OAAO,KAAK,EAAE,UAAU,WAAW;AAAA,MAAE;AAAA,IACrE;AAAA,EACF;AAAA,EAEA,UAAU,KAAiB,GAAW,SAAqC,IAAI,IAAgD;AAC7H,UAAMA,KAAI,KAAK;AAEf,QAAI,eAAe;AAEnB,QAAI,MAAM,IAAI;AACd,QAAI,QAAQ,IAAI,OAAOA,GAAE,EAAE,YAAY;AACvC,QAAI,UAAU,IAAI,OAAOA,GAAE,EAAE,UAAU;AACvC,QAAI,QAAQ,IAAI,MAAMA,GAAE,EAAE,MAAM;AAEhC,QAAI,MAAM,KAAK,SAAS;AACxB,QAAI,QAAQ,KAAK,SAAS;AAG1B,QAAI,UAAU,MAAM;AAClB,WAAK,cAAcA,GAAE,EAAE,OAAO,KAAK,GAAG,CAAC;AAAA,IACzC;AAEA,QAAI,UAAU,IAAI;AAChB,UAAI,YAAY,IAAI,MAAMA,GAAE,EAAE,UAAU;AACxC,UAAI,UAAU,IAAI,MAAMA,GAAE,EAAE,YAAY,EAAE,CAAC;AAE3C,UAAI,WAAW,MAAM;AACnB,gBAAQ;AAAA,MACV,OAAO;AACL,YAAI,QAAQ,UAAU,CAAC,KAAK;AAC5B,aAAK,WAAW,OAAO,MAAM,MAAM,GAAG,CAAC;AAAA,MACzC;AAEA,cAAQ;AACR,YAAM,UAAU;AAAA,IAClB,OAAO;AACL,WAAK,WAAW,OAAO,IAAI,MAAM,GAAG,CAAC;AAAA,IACvC;AAEA,QAAI,OAAO,aAAa,OAAO,CAAC;AAEhC,QAAI,IAAI;AACR,QAAI,IAAI;AAER,QAAI,IAAI,UAAU;AAChB,UAAI,SAAS,QAAQ,WAAS,KAAK,UAAU,OAAO,IAAI,GAAG,SAAS,CAAC,CAAC;AAAA,IACxE;AAEA,WAAO,CAAC,KAAK,OAAO;AAAA,EACtB;AAAA,EAEA,aAAa,CAAC,OAAiB,QAAe,IAAI,QAAQ,CAAC,OAAO,SAAS;AAEzE,YAAQ,MAAM,CAAC,GAAG;AAAA,MAChB,KAAK;AACH,aAAK,UAAU,OAAO,KAAK;AAC3B;AAAA,MAEF,KAAK;AACH,aAAK,aAAa,OAAO,KAAK;AAC9B;AAAA,MAEF,KAAK;AACH,YAAI,YAAY,KAAK,QAAQ,KAAK;AAClC,YAAI,CAAC,UAAW;AAEhB,YAAI,QAAQ,QAAQ,UAAU,CAAC,EAAE,MAAM,CAAC,IAAI,OAAQ,UAAU,CAAC,IAAI,GAAI;AACvE,cAAM,OAAO,GAAG,MAAM,OAAO,MAAM,OAAO,MAAM,EAAE,GAAG,KAAK;AAC1D;AAAA,MAEF,KAAK;AACH,YAAI,YAAY,KAAK,QAAQ,KAAK;AAClC,YAAI,CAAC,UAAW;AAEhB,YAAI,QAAQ,GAAG,UAAU,CAAC,EAAE,MAAM,CAAC,IAAI,OAAQ,UAAU,CAAC,IAAI,GAAI;AAElE,cAAM,OAAO,GAAG,MAAM,OAAO,MAAM,OAAO,MAAM,EAAE,GAAG,KAAK;AAE1D;AAAA,MAEF,KAAK;AAUH,gBAAQ,KAAK,cAAc,OAAO,KAAK;AACvC;AAAA,MAEF;AACE,cAAM,MAAM,GAAG,MAAM,MAAM,MAAM,MAAM,MAAM,EAAE,GAAG,KAAK;AAAA,IAC3D;AAAA,EACF,CAAC;AAAA,EAED,aAAa,OAAiB,OAAY;AACxC,UAAM,QAAQ,GAAG,MAAM,QAAQ,MAAM,QAAQ,MAAM,EAAE,GAAG,MAAM,QAAQ,KAAK,GAAG,CAAC;AAAA,EACjF;AAAA,EAEA,UAAU,OAAiB,OAAY;AACrC,UAAM,KAAK,GAAG,MAAM,KAAK,MAAM,KAAK,MAAM,EAAE,GAAG,MAAM,QAAQ,KAAK,GAAG,CAAC;AAAA,EACxE;AAAA,EAEA,cAAc,OAAY,OAAiB;AACzC,YAAQ,IAAI,WAAW,GAAG,KAAK,GAAG,MAAM,CAAC,GAAG,GAAG,KAAK,GAAG,MAAM,gBAAgB,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AAE1F,QAAI,MAAM,SAAS,QAAQ,EAAG,EAAC,YAAY;AACzC,cAAQ,MAAM,MAAM,CAAC;AAErB,UAAI,QAAQ,UAAU,QAAQ;AAC5B,gBAAQ,GAAG,KAAK,GAAG,SAAS,UAAU,IAClC,MAAM,QAAQ,YAAY,OAAO,SAAS,MAAM,IAChD;AAAA,MACN;AAEA,YAAM,MAAM,MAAM,MACd,MAAM,MACN;AAEJ,YAAM,OACJ,GAAG,MAAM,OAAO,MAAM,OAAO,MAAM,EAAE,gBAAgB,KAAK,qBACrC,oBAAI,KAAK,GAAE,QAAQ,CAAC;AAG3C,UAAI,KAAK,MAAM,MAAM,MAAM,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,KAAK;AAAA,QACpD,MAAM,MAAM;AAAE,iBAAO;AAAA,QAAO;AAAA,MAC9B;AAEA,UAAI,SAAS,MAAM,GAAG,KAAK;AAC3B,YAAM,UAAU,GAAG,SAAS,SAAS,EAAE;AAGvC,UAAI,QAAQ,UAAU,QAAQ;AAC5B,YAAI,KAAK,KAAK,EAAE,IAAI,MAAM,KAAK,MAAM,GAAG,EAAE,KAAK,IAAI,CAAC,GAAG;AACvD,YAAI;AACF,aAAG,YAAY,MAAM,QAAQ,QAAQ,OAAO,WAAW;AAAA,MAC3D;AAAA,IACF,GAAG;AACH,WAAO;AAAA,EACT;AAAA,EAEA,eAAe,KAAiB,OAAO,KAAK,aAAa,GAAG;AAC1D,UAAM,IAAI,IAAI;AACd,QAAI,CAAC,EAAG,OAAM,IAAI,OAAO,sBAAsB;AAE/C,QAAI,aAAa;AACjB,QAAI,UAAU;AAEd,QAAI,cAAc,KAAK,SAAS,EAAE,KAAK,KAAK,YAAY;AACxD,QAAI,YAAY,YAAY;AAC5B,QAAI,SAAS,YAAY;AAEzB,QAAI,OAAO;AAEX,SAAK,gBAAgB,KAAK,IAAI;AAE9B,WAAO;AAAA,EAAK,IAAI,CAAC,IAAI,EAAE,GAAG;AAE1B,UAAM,KAAK,CAAC,MAAW,CAAC,CAAC;AACzB,UAAM,QAAQ,CAAC,MAAW,QAAQ;AAElC,YAAQ,MAAM;AAAA,MAEZ,KAAK,GAAG,EAAE,KAAK;AAAG,cAAM,WAAW,EAAE,KACnC,GAAG;AAAA,MACL,KAAK,GAAG,EAAE,EAAE;AAAG,cAAM,QAAQ,EAAE,EAAE,GAAG;AAAA,MACpC,KAAK,GAAG,EAAE,KAAK;AAAG,cAAM,WAAW,EAAE,KAAK,GAAG;AAAA,MAC7C,KAAK,GAAG,EAAE,IAAI;AAAG,cAAM,IAAI,EAAE,IAAI,EAAE;AAAA,MACnC,KAAK,GAAG,EAAE,IAAI;AAAG,cAAM,IAAI,EAAE,IAAI,EAAE;AAAA,IACrC;AAEA,QAAI,YAAY,EAAG,WAAU;AAE7B,YAAQ,UACJ,UACA;AAGJ,eAAW,SAAS,IAAI,SAAU,SAAQ,MAAM,EAAE,CAAC,GAAG;AAAA,MACpD,KAAK;AACH,gBAAQ,MAAM,IAAI,MAAM,EAAE,MAAM,GAAG,MAAM,EAAE,SAAS,CAAC;AACrD;AAAA,MAEF;AACE,gBAAQ,MAAM,IAAI,KAAK,eAAe,OAAO,IAAI;AAAA,IACrD;AAEA,YAAQ,CAAC,UACL;AAAA,EAAK,IAAI,CAAC,KAAK,EAAE,GAAG;AAAA,IACpB;AAGJ,QAAI,KAAK,OAAO,IAAI,EAAG,QAAO,KAC3B,QAAQ,MAAM,EAAE,EAChB,QAAQ,OAAO,EAAE;AAEpB,QAAI,KAAK,SAAS,MAAM,GAAG;AAEzB,eAAS,SAAS,KAAK,QAAQ;AAC7B,YAAI,KAAK,OAAO,KAAK,MAAM,QAAQ,KAAK,OAAO,OAAO,KAAK,GAAG;AAC5D,iBAAO,KAAK,QAAQ,UAAU,aAAa,KAAK,OAAO,OAAO,KAAK,CAAC;AAIpE,eAAK,OAAO,KAAK,IAAI;AAAA,QACvB;AAAA,MACF;AAAA,IAEF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,KAAiB,OAAO,KAAK,aAAa,GAAG;AAC3D,UAAM,EAAE,EAAE,IAAI;AACd,QAAI,CAAC,EAAG,OAAM,IAAI,OAAO,sBAAsB;AAC/C,YAAQ,EAAE,KAAK;AAAA,IAEf;AAAA,EACF;AAAA,EAEA,cAAc,KAAiB,IAAI,IAAI;AACrC,QAAI,UAAU,KAAK,aAAa;AAEhC,QAAI,UAAU,KAAK,UAAU,KAAK,GAAG,SAAS,CAAC;AAG/C;AAAE,OAAC,KAAK,OAAO,IAAI;AAAA,IAAQ;AAE3B,QAAI,MAAM,KAAK,eAAe,KAAK,OAAO;AAE1C,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,QAAgB;AACpB,QAAI,MAAM,KAAK,eAAe,MAAM;AAEpC,QAAI,UAAU,KAAK,mBAAmB,GAAG;AAEzC,QAAI,SAAS,KAAK,eAAe,OAAO;AAExC,WAAO,KAAK,cAAc,OAAO,CAAC,CAAC;AAAA,EACrC;AAAA,EAEA,MAAM,SAAS,eAAoB;AACjC,eAAW,YAAY,eAAe;AACpC,UAAI;AACF,cAAM,WAAW,MAAM,MAAM,QAAQ;AAGrC,YAAI,SAAS,IAAI;AACf,iBAAO;AAAA,QACT;AAAA,MACF,SAAS,OAAO;AAEd,gBAAQ,MAAM,6BAA6B,QAAQ,MAAM,KAAK;AAAA,MAChE;AAAA,IACF;AAGA,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ,KAAa,SAAS,mBAAmB;AAC/C,IAAC,MAAc,KAAK,MAAM,GAAG;AAC7B,aAAS,KAAK;AACd,aAAS,MAAM,SAAS,OAAO,GAAG;AAClC,aAAS,MAAM;AAAA,EACjB;AAAA,EAEA,WAAW,OAAe;AAWxB,QAAI,WAAW,KAAK,MAAM,KAAK;AAE/B,QAAI,QAAQ,WAAW,KAAM,SAAQ,IAAI,QAAQ;AAEjD,QAAI,YAAY,QAAQ,gBAAgB;AACxC,QAAI,cAAc,KAAK,EAAE,SAAS;AAClC,QAAI,CAAC,YAAa,aAAY;AAAA,QACzB,aAAY,YAAY;AAG7B,YAAQ,eAAe,WAAW;AAAA,EACpC;AAAA,EAEA,SAAS,MAAM,OAAO;AAAA,IACpB,UAAU,iBAAiB;AAAA,IAE3B,cAAc;AACZ,cAAQ,KAAK,SAAS;AAAA,QACpB,KAAK;AACH;AAAA,QACF,KAAK;AACH;AAAA,MACJ;AAAA,IACF;AAAA,EAEF;AAAA;AAAA,EAGA,QAAQ,KAAa,MAAM,KAAK;AAC9B,QAAI,SAAS,OAAO;AACpB,aAAS,OACN,QAAQ,KAAK,IAAI,EACjB,QAAQ,KAAK,MAAM,EACnB,QAAQ,KAAM,KAAK,EACnB,QAAQ,KAAK,GAAG;AAEnB,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ,KAAa;AACnB,QAAI;AACF,UAAI,GAAG,GAAG,GAAG,MAAM,KAAK,GAAI,SAAS,EAAG,OAAM,KAAK,EAAE,UAAU;AAE/D,UAAI,YAAY,IAEb,QAAQ,KAAK,wBAAwB,EACrC,QAAQ,OAAO,sBAAsB,EAErC,QAAQ,SAAS,GAAG,EACpB,QAAQ,WAAW,GAAG,EACtB,QAAQ,UAAU,GAAI,EACtB,QAAQ,QAAQ,GAAG,EAEnB,QAAQ,wBAAwB,GAAG,EAGnC,MAAM,wBAAwB;AAGjC,aAAO;AAAA,IACT,QAAQ;AAAA,IAAE;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,KAA8C;AAC7D,UAAM,WAAW,MAAM,MAAM,GAAG;AAChC,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,uBAAuB,SAAS,MAAM,EAAE;AAC1D,UAAM,OAAO,MAAM,SAAS,KAAK;AACjC,YAAQ,IAAI,KAAK,WAAW,IAAI,CAAC;AACjC,WAAO,KAAK,WAAW,IAAI;AAAA,EAC7B;AAAA,EAEA,YAAY;AACV,QAAI,MAAM,OAAO,SAAS;AAC1B,QAAI,QAAQ,IAAI,MAAM,GAAG;AACzB,QAAI,WAAW,MAAM,MAAM,SAAS,CAAC;AAErC,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,OAAe;AAC1B,QAAI,UAAU,SAAS,cAAc,KAAK;AAC1C,YAAQ,YAAY;AACpB,QAAI,iBAAiB,QAAQ;AAC7B,WAAO;AAAA,EACT;AAAA,EAEA,iBAAiB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKlB,UAAU,OAAe,MAAc;AACrC,QAAI,CAAC,KAAK,gBAAgB;AACxB,WAAK,iBAAiB,CAAC;AAAA,IACzB;AAEA,QAAI,KAAK,eAAe,IAAI,MAAM,QAAW;AAC3C,WAAK,eAAe,IAAI,KAAK;AAAA,IAC/B,OAAO;AACL,WAAK,eAAe,IAAI,IAAI;AAAA,IAC9B;AAEA,QAAI;AACJ,QAAI,KAAK,SAAS,GAAG,GAAG;AACtB,UAAI,IAAI,KAAK,MAAM,GAAG;AACtB,QAAE,CAAC,KAAK,KAAK,KAAK,eAAe,IAAI,CAAC;AACtC,mBAAa,EAAE,KAAK,EAAE;AAAA,IACxB,OAAO;AACL,mBAAa,OAAO;AAAA,IACtB;AAEA,WAAO;AAAA,MACL;AAAA,MACA,GAAG,KAAK;AAAA,MACR,GAAI,MAAM,KAAK,UAAU,KAAK,cAAc;AAAA,MAC5C,GAAI,MAAM,KAAK,MAAM,KAAK,UAAU,KAAK,cAAc,CAAC;AAAA,IAC1D;AAAA,EACF;AAAA,EAEA,YAAY,KAAa;AACvB,WAAO,IACJ,QAAQ,2BAA2B,MAAM,EACzC,QAAQ,QAAQ,MAAM;AAAA,EAC3B;AAAA,EAEA,WAAW,KAAa;AACtB,UAAM,aAAa,IAAI,QAAQ,SAAS,GAAG;AAC3C,UAAM,eAAe,WAAW,QAAQ,YAAY,GAAG;AAEvD,WAAO;AAAA,MACL;AAAA,MACA,KAAK,MAAM,YAAY;AAAA,IACzB;AAAA,EACF;AAAA;AAAA,EAGA,aAAa,CAAC,MAAc,QAAQ,OAAO;AACzC,UAAM,MAAM,IAAI,UAAU,EAAE,gBAAgB,MAAM,WAAW;AAE7D,WAAO,KAAK,WAAW,IAAI,iBAAiB,IAAI,KAAK;AAAA,EACvD;AAAA,EAEA,aAAa,CAAC,MAAe,SAAS,IAAI,QAAQ,OAAO;AACvD,QAAI,SAAS;AAGb,cAAU,GAAG,MAAM,GAAG,KAAK,SAAS,YAAY,CAAC;AAIjD,QAAI,KAAK,WAAW,SAAS,GAAG;AAC9B,YAAM,QAAQ,MAAM,KAAK,KAAK,UAAU;AACxC,eAAS,KAAK,YAAY,OAAO,MAAM;AAAA,IACzC;AAGA,QAAI,KAAK,WAAW,SAAS;AAC3B,eAAS,KAAK,gBAAgB,QAAQ,MAAM,QAAQ,KAAK;AAAA;AAEzD,gBAAU;AAEZ,WAAO;AAAA,EACT;AAAA,EAEA,qBAAqB,OAAgB,QAAgB;AACnD,QAAI,CAAC,MAAM,YAAa,QAAO;AAC/B,QAAI,IAAI,MAAM,YAAY,KAAK;AAC/B,QAAI,KAAK,GAAI,QAAO,GAAG,MAAM,MAAM,CAAC;AAAA;AAAA,EACtC;AAAA,EAEA,gBAAgB,QAAgB,MAAe,QAAgB,OAAe;AAC5E,cAAU;AACV,UAAM,aAAa,MAAM,KAAK,KAAK,UAAU;AAC7C,eAAW,SAAS,WAAY,SAAQ,MAAM,UAAU;AAAA,MACtD,KAAK,KAAK;AACR,kBAAU,KAAK,qBAAqB,OAAkB,MAAM;AAC5D;AAAA,MACF,KAAK,KAAK;AACR,kBAAU,KAAK,WAAW,OAAkB,SAAS,MAAM,KAAK;AAChE;AAAA,IACJ;AACA,cAAU,GAAG,MAAM,GAAG,KAAK;AAAA;AAC3B,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,OAAe,QAAgB;AACzC,UAAM,MAAM,CAAC,SAAe,KAAK,QAAQ,KAAK,KAAK;AACnD,eAAW,QAAQ,MAAO,SAAQ,KAAK,KAAK,YAAY,GAAG;AAAA,MACzD,KAAK;AACH,kBAAU,KAAK,IAAI,IAAI,CAAC;AACxB;AAAA,MACF,KAAK;AACH,kBAAU,KAAK,IAAI,IAAI,CAAC;AAAA,MAE1B;AAAS,kBAAU,KAAK,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC;AAAA,IAChD;AACA,WAAO;AAAA,EACT;AAAA,EAEA,cAAc;AACZ,UAAM;AAEN,QAAI;AAAE,WAAK,iBAAiB;AAAA,IAAE,QAAQ;AAAA,IAAE;AAAA,EAC1C;AAAA,EAEA,mBAAmB;AAAA,EAEnB;AACF;AAEA,IAAM,SAAS,IAAI;AAGnB,IAAI;AAAE,SAAO,UAAU;AAAO,QAAQ;AAAE;AACxC,IAAI;AAAE,UAAQ,OAAO,SAAS;AAAO,QAAQ;AAAE;","names":["r"]}